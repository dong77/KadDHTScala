// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: protocol.proto

package com.coinport

final case class Key (
	`raw`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Key]
	with net.sandrogrzicic.scalabuff.Parser[Key] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeBytes(1, `raw`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeBytesSize(1, `raw`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Key = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __raw: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

		def __newMerged = Key(
			__raw
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __raw = in.readBytes()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Key) = {
		Key(
			m.`raw`
		)
	}

	def getDefaultInstanceForType = Key.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Key {
	@beans.BeanProperty val defaultInstance = new Key()

	def parseFrom(data: Array[Byte]): Key = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Key = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Key = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Key = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Key] = defaultInstance.mergeDelimitedFromStream(stream)

	val RAW_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Key) = defaultInstance.mergeFrom(prototype)

}
final case class Contact (
	`host`: String = "",
	`port`: Int = 0,
	`id`: Option[Key] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Contact]
	with net.sandrogrzicic.scalabuff.Parser[Contact] {

	def setId(_f: Key) = copy(`id` = Some(_f))

	def clearId = copy(`id` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `host`)
		output.writeInt32(2, `port`)
		if (`id`.isDefined) output.writeMessage(3, `id`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `host`)
		__size += computeInt32Size(2, `port`)
		if (`id`.isDefined) __size += computeMessageSize(3, `id`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Contact = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __host: String = ""
		var __port: Int = 0
		var __id: Option[Key] = `id`

		def __newMerged = Contact(
			__host,
			__port,
			__id
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __host = in.readString()
			case 16 => __port = in.readInt32()
			case 26 => __id = Some(readMessage[Key](in, __id.orElse({
				__id = Key.defaultInstance
				__id
			}).get, _emptyRegistry))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Contact) = {
		Contact(
			m.`host`,
			m.`port`,
			m.`id`.orElse(`id`)
		)
	}

	def getDefaultInstanceForType = Contact.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Contact {
	@beans.BeanProperty val defaultInstance = new Contact()

	def parseFrom(data: Array[Byte]): Contact = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Contact = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Contact = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Contact = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Contact] = defaultInstance.mergeDelimitedFromStream(stream)

	val HOST_FIELD_NUMBER = 1
	val PORT_FIELD_NUMBER = 2
	val ID_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Contact) = defaultInstance.mergeFrom(prototype)

}
final case class Node (
	`contact`: Contact = Contact.defaultInstance,
	`data`: Option[com.google.protobuf.ByteString] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Node]
	with net.sandrogrzicic.scalabuff.Parser[Node] {

	def setData(_f: com.google.protobuf.ByteString) = copy(`data` = Some(_f))

	def clearData = copy(`data` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `contact`)
		if (`data`.isDefined) output.writeBytes(2, `data`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `contact`)
		if (`data`.isDefined) __size += computeBytesSize(2, `data`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Node = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __contact: Contact = Contact.defaultInstance
		var __data: Option[com.google.protobuf.ByteString] = `data`

		def __newMerged = Node(
			__contact,
			__data
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __contact = readMessage[Contact](in, __contact, _emptyRegistry)
			case 18 => __data = Some(in.readBytes())
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Node) = {
		Node(
			m.`contact`,
			m.`data`.orElse(`data`)
		)
	}

	def getDefaultInstanceForType = Node.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Node {
	@beans.BeanProperty val defaultInstance = new Node()

	def parseFrom(data: Array[Byte]): Node = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Node = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Node = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Node = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Node] = defaultInstance.mergeDelimitedFromStream(stream)

	val CONTACT_FIELD_NUMBER = 1
	val DATA_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Node) = defaultInstance.mergeFrom(prototype)

}
final case class PING (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[PING]
	with net.sandrogrzicic.scalabuff.Parser[PING] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): PING = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = PING(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: PING) = {
		PING(

		)
	}

	def getDefaultInstanceForType = PING.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object PING {
	@beans.BeanProperty val defaultInstance = new PING()

	def parseFrom(data: Array[Byte]): PING = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): PING = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): PING = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): PING = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[PING] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: PING) = defaultInstance.mergeFrom(prototype)

}
final case class OK (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[OK]
	with net.sandrogrzicic.scalabuff.Parser[OK] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): OK = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = OK(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: OK) = {
		OK(

		)
	}

	def getDefaultInstanceForType = OK.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object OK {
	@beans.BeanProperty val defaultInstance = new OK()

	def parseFrom(data: Array[Byte]): OK = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): OK = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): OK = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): OK = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[OK] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: OK) = defaultInstance.mergeFrom(prototype)

}
final case class STORE (
	`content`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[STORE]
	with net.sandrogrzicic.scalabuff.Parser[STORE] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeBytes(1, `content`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeBytesSize(1, `content`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): STORE = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __content: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

		def __newMerged = STORE(
			__content
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __content = in.readBytes()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: STORE) = {
		STORE(
			m.`content`
		)
	}

	def getDefaultInstanceForType = STORE.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object STORE {
	@beans.BeanProperty val defaultInstance = new STORE()

	def parseFrom(data: Array[Byte]): STORE = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): STORE = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): STORE = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): STORE = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[STORE] = defaultInstance.mergeDelimitedFromStream(stream)

	val CONTENT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: STORE) = defaultInstance.mergeFrom(prototype)

}
final case class FIND_NODE (
	`id`: Key = Key.defaultInstance
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[FIND_NODE]
	with net.sandrogrzicic.scalabuff.Parser[FIND_NODE] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `id`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `id`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): FIND_NODE = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __id: Key = Key.defaultInstance

		def __newMerged = FIND_NODE(
			__id
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __id = readMessage[Key](in, __id, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: FIND_NODE) = {
		FIND_NODE(
			m.`id`
		)
	}

	def getDefaultInstanceForType = FIND_NODE.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object FIND_NODE {
	@beans.BeanProperty val defaultInstance = new FIND_NODE()

	def parseFrom(data: Array[Byte]): FIND_NODE = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): FIND_NODE = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): FIND_NODE = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): FIND_NODE = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[FIND_NODE] = defaultInstance.mergeDelimitedFromStream(stream)

	val ID_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: FIND_NODE) = defaultInstance.mergeFrom(prototype)

}
final case class FIND_NODE_RESP (
	`nodes`: scala.collection.immutable.Seq[Node] = Vector.empty[Node]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[FIND_NODE_RESP]
	with net.sandrogrzicic.scalabuff.Parser[FIND_NODE_RESP] {

	def setNodes(_i: Int, _v: Node) = copy(`nodes` = `nodes`.updated(_i, _v))
	def addNodes(_f: Node) = copy(`nodes` = `nodes` :+ _f)
	def addAllNodes(_f: Node*) = copy(`nodes` = `nodes` ++ _f)
	def addAllNodes(_f: TraversableOnce[Node]) = copy(`nodes` = `nodes` ++ _f)

	def clearNodes = copy(`nodes` = Vector.empty[Node])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		for (_v <- `nodes`) output.writeMessage(1, _v)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		for (_v <- `nodes`) __size += computeMessageSize(1, _v)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): FIND_NODE_RESP = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		val __nodes: scala.collection.mutable.Buffer[Node] = `nodes`.toBuffer

		def __newMerged = FIND_NODE_RESP(
			Vector(__nodes: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __nodes += readMessage[Node](in, Node.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: FIND_NODE_RESP) = {
		FIND_NODE_RESP(
			`nodes` ++ m.`nodes`
		)
	}

	def getDefaultInstanceForType = FIND_NODE_RESP.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object FIND_NODE_RESP {
	@beans.BeanProperty val defaultInstance = new FIND_NODE_RESP()

	def parseFrom(data: Array[Byte]): FIND_NODE_RESP = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): FIND_NODE_RESP = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): FIND_NODE_RESP = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): FIND_NODE_RESP = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[FIND_NODE_RESP] = defaultInstance.mergeDelimitedFromStream(stream)

	val NODES_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: FIND_NODE_RESP) = defaultInstance.mergeFrom(prototype)

}
final case class FIND_VALUE (
	`key`: Key = Key.defaultInstance
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[FIND_VALUE]
	with net.sandrogrzicic.scalabuff.Parser[FIND_VALUE] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `key`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `key`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): FIND_VALUE = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __key: Key = Key.defaultInstance

		def __newMerged = FIND_VALUE(
			__key
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __key = readMessage[Key](in, __key, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: FIND_VALUE) = {
		FIND_VALUE(
			m.`key`
		)
	}

	def getDefaultInstanceForType = FIND_VALUE.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object FIND_VALUE {
	@beans.BeanProperty val defaultInstance = new FIND_VALUE()

	def parseFrom(data: Array[Byte]): FIND_VALUE = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): FIND_VALUE = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): FIND_VALUE = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): FIND_VALUE = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[FIND_VALUE] = defaultInstance.mergeDelimitedFromStream(stream)

	val KEY_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: FIND_VALUE) = defaultInstance.mergeFrom(prototype)

}
final case class FIND_VALUE_RESP (
	`key`: Option[Key] = None,
	`value`: Option[com.google.protobuf.ByteString] = None,
	`nodes`: scala.collection.immutable.Seq[Node] = Vector.empty[Node]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[FIND_VALUE_RESP]
	with net.sandrogrzicic.scalabuff.Parser[FIND_VALUE_RESP] {

	def setKey(_f: Key) = copy(`key` = Some(_f))
	def setValue(_f: com.google.protobuf.ByteString) = copy(`value` = Some(_f))
	def setNodes(_i: Int, _v: Node) = copy(`nodes` = `nodes`.updated(_i, _v))
	def addNodes(_f: Node) = copy(`nodes` = `nodes` :+ _f)
	def addAllNodes(_f: Node*) = copy(`nodes` = `nodes` ++ _f)
	def addAllNodes(_f: TraversableOnce[Node]) = copy(`nodes` = `nodes` ++ _f)

	def clearKey = copy(`key` = None)
	def clearValue = copy(`value` = None)
	def clearNodes = copy(`nodes` = Vector.empty[Node])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		if (`key`.isDefined) output.writeMessage(1, `key`.get)
		if (`value`.isDefined) output.writeBytes(2, `value`.get)
		for (_v <- `nodes`) output.writeMessage(3, _v)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		if (`key`.isDefined) __size += computeMessageSize(1, `key`.get)
		if (`value`.isDefined) __size += computeBytesSize(2, `value`.get)
		for (_v <- `nodes`) __size += computeMessageSize(3, _v)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): FIND_VALUE_RESP = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __key: Option[Key] = `key`
		var __value: Option[com.google.protobuf.ByteString] = `value`
		val __nodes: scala.collection.mutable.Buffer[Node] = `nodes`.toBuffer

		def __newMerged = FIND_VALUE_RESP(
			__key,
			__value,
			Vector(__nodes: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __key = Some(readMessage[Key](in, __key.orElse({
				__key = Key.defaultInstance
				__key
			}).get, _emptyRegistry))
			case 18 => __value = Some(in.readBytes())
			case 26 => __nodes += readMessage[Node](in, Node.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: FIND_VALUE_RESP) = {
		FIND_VALUE_RESP(
			m.`key`.orElse(`key`),
			m.`value`.orElse(`value`),
			`nodes` ++ m.`nodes`
		)
	}

	def getDefaultInstanceForType = FIND_VALUE_RESP.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object FIND_VALUE_RESP {
	@beans.BeanProperty val defaultInstance = new FIND_VALUE_RESP()

	def parseFrom(data: Array[Byte]): FIND_VALUE_RESP = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): FIND_VALUE_RESP = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): FIND_VALUE_RESP = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): FIND_VALUE_RESP = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[FIND_VALUE_RESP] = defaultInstance.mergeDelimitedFromStream(stream)

	val KEY_FIELD_NUMBER = 1
	val VALUE_FIELD_NUMBER = 2
	val NODES_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: FIND_VALUE_RESP) = defaultInstance.mergeFrom(prototype)

}
final case class Msg (
	`ping`: Option[PING] = None,
	`store`: Option[STORE] = None,
	`findNode`: Option[FIND_NODE] = None,
	`findNodeResp`: Option[FIND_NODE_RESP] = None,
	`ok`: Option[OK] = None,
	`findValue`: Option[FIND_VALUE] = None,
	`findValueResp`: Option[FIND_VALUE_RESP] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Msg]
	with net.sandrogrzicic.scalabuff.Parser[Msg] {

	def setPing(_f: PING) = copy(`ping` = Some(_f))
	def setStore(_f: STORE) = copy(`store` = Some(_f))
	def setFindNode(_f: FIND_NODE) = copy(`findNode` = Some(_f))
	def setFindNodeResp(_f: FIND_NODE_RESP) = copy(`findNodeResp` = Some(_f))
	def setOk(_f: OK) = copy(`ok` = Some(_f))
	def setFindValue(_f: FIND_VALUE) = copy(`findValue` = Some(_f))
	def setFindValueResp(_f: FIND_VALUE_RESP) = copy(`findValueResp` = Some(_f))

	def clearPing = copy(`ping` = None)
	def clearStore = copy(`store` = None)
	def clearFindNode = copy(`findNode` = None)
	def clearFindNodeResp = copy(`findNodeResp` = None)
	def clearOk = copy(`ok` = None)
	def clearFindValue = copy(`findValue` = None)
	def clearFindValueResp = copy(`findValueResp` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		if (`ping`.isDefined) output.writeMessage(1, `ping`.get)
		if (`store`.isDefined) output.writeMessage(2, `store`.get)
		if (`findNode`.isDefined) output.writeMessage(3, `findNode`.get)
		if (`findNodeResp`.isDefined) output.writeMessage(4, `findNodeResp`.get)
		if (`ok`.isDefined) output.writeMessage(5, `ok`.get)
		if (`findValue`.isDefined) output.writeMessage(6, `findValue`.get)
		if (`findValueResp`.isDefined) output.writeMessage(7, `findValueResp`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		if (`ping`.isDefined) __size += computeMessageSize(1, `ping`.get)
		if (`store`.isDefined) __size += computeMessageSize(2, `store`.get)
		if (`findNode`.isDefined) __size += computeMessageSize(3, `findNode`.get)
		if (`findNodeResp`.isDefined) __size += computeMessageSize(4, `findNodeResp`.get)
		if (`ok`.isDefined) __size += computeMessageSize(5, `ok`.get)
		if (`findValue`.isDefined) __size += computeMessageSize(6, `findValue`.get)
		if (`findValueResp`.isDefined) __size += computeMessageSize(7, `findValueResp`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Msg = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __ping: Option[PING] = `ping`
		var __store: Option[STORE] = `store`
		var __findNode: Option[FIND_NODE] = `findNode`
		var __findNodeResp: Option[FIND_NODE_RESP] = `findNodeResp`
		var __ok: Option[OK] = `ok`
		var __findValue: Option[FIND_VALUE] = `findValue`
		var __findValueResp: Option[FIND_VALUE_RESP] = `findValueResp`

		def __newMerged = Msg(
			__ping,
			__store,
			__findNode,
			__findNodeResp,
			__ok,
			__findValue,
			__findValueResp
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __ping = Some(readMessage[PING](in, __ping.orElse({
				__ping = PING.defaultInstance
				__ping
			}).get, _emptyRegistry))
			case 18 => __store = Some(readMessage[STORE](in, __store.orElse({
				__store = STORE.defaultInstance
				__store
			}).get, _emptyRegistry))
			case 26 => __findNode = Some(readMessage[FIND_NODE](in, __findNode.orElse({
				__findNode = FIND_NODE.defaultInstance
				__findNode
			}).get, _emptyRegistry))
			case 34 => __findNodeResp = Some(readMessage[FIND_NODE_RESP](in, __findNodeResp.orElse({
				__findNodeResp = FIND_NODE_RESP.defaultInstance
				__findNodeResp
			}).get, _emptyRegistry))
			case 42 => __ok = Some(readMessage[OK](in, __ok.orElse({
				__ok = OK.defaultInstance
				__ok
			}).get, _emptyRegistry))
			case 50 => __findValue = Some(readMessage[FIND_VALUE](in, __findValue.orElse({
				__findValue = FIND_VALUE.defaultInstance
				__findValue
			}).get, _emptyRegistry))
			case 58 => __findValueResp = Some(readMessage[FIND_VALUE_RESP](in, __findValueResp.orElse({
				__findValueResp = FIND_VALUE_RESP.defaultInstance
				__findValueResp
			}).get, _emptyRegistry))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Msg) = {
		Msg(
			m.`ping`.orElse(`ping`),
			m.`store`.orElse(`store`),
			m.`findNode`.orElse(`findNode`),
			m.`findNodeResp`.orElse(`findNodeResp`),
			m.`ok`.orElse(`ok`),
			m.`findValue`.orElse(`findValue`),
			m.`findValueResp`.orElse(`findValueResp`)
		)
	}

	def getDefaultInstanceForType = Msg.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Msg {
	@beans.BeanProperty val defaultInstance = new Msg()

	def parseFrom(data: Array[Byte]): Msg = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Msg = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Msg = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Msg = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Msg] = defaultInstance.mergeDelimitedFromStream(stream)

	val PING_FIELD_NUMBER = 1
	val STORE_FIELD_NUMBER = 2
	val FINDNODE_FIELD_NUMBER = 3
	val FINDNODERESP_FIELD_NUMBER = 4
	val OK_FIELD_NUMBER = 5
	val FINDVALUE_FIELD_NUMBER = 6
	val FINDVALUERESP_FIELD_NUMBER = 7

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Msg) = defaultInstance.mergeFrom(prototype)

}
final case class SendMessage (
	`dest`: Contact = Contact.defaultInstance,
	`msg`: Msg = Msg.defaultInstance
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[SendMessage]
	with net.sandrogrzicic.scalabuff.Parser[SendMessage] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `dest`)
		output.writeMessage(2, `msg`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `dest`)
		__size += computeMessageSize(2, `msg`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): SendMessage = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __dest: Contact = Contact.defaultInstance
		var __msg: Msg = Msg.defaultInstance

		def __newMerged = SendMessage(
			__dest,
			__msg
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __dest = readMessage[Contact](in, __dest, _emptyRegistry)
			case 18 => __msg = readMessage[Msg](in, __msg, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: SendMessage) = {
		SendMessage(
			m.`dest`,
			m.`msg`
		)
	}

	def getDefaultInstanceForType = SendMessage.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object SendMessage {
	@beans.BeanProperty val defaultInstance = new SendMessage()

	def parseFrom(data: Array[Byte]): SendMessage = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): SendMessage = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): SendMessage = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): SendMessage = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[SendMessage] = defaultInstance.mergeDelimitedFromStream(stream)

	val DEST_FIELD_NUMBER = 1
	val MSG_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: SendMessage) = defaultInstance.mergeFrom(prototype)

}
final case class AddSeeds (
	`seeds`: scala.collection.immutable.Seq[Contact] = Vector.empty[Contact]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[AddSeeds]
	with net.sandrogrzicic.scalabuff.Parser[AddSeeds] {

	def setSeeds(_i: Int, _v: Contact) = copy(`seeds` = `seeds`.updated(_i, _v))
	def addSeeds(_f: Contact) = copy(`seeds` = `seeds` :+ _f)
	def addAllSeeds(_f: Contact*) = copy(`seeds` = `seeds` ++ _f)
	def addAllSeeds(_f: TraversableOnce[Contact]) = copy(`seeds` = `seeds` ++ _f)

	def clearSeeds = copy(`seeds` = Vector.empty[Contact])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		for (_v <- `seeds`) output.writeMessage(1, _v)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		for (_v <- `seeds`) __size += computeMessageSize(1, _v)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): AddSeeds = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		val __seeds: scala.collection.mutable.Buffer[Contact] = `seeds`.toBuffer

		def __newMerged = AddSeeds(
			Vector(__seeds: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __seeds += readMessage[Contact](in, Contact.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: AddSeeds) = {
		AddSeeds(
			`seeds` ++ m.`seeds`
		)
	}

	def getDefaultInstanceForType = AddSeeds.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object AddSeeds {
	@beans.BeanProperty val defaultInstance = new AddSeeds()

	def parseFrom(data: Array[Byte]): AddSeeds = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): AddSeeds = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): AddSeeds = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): AddSeeds = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[AddSeeds] = defaultInstance.mergeDelimitedFromStream(stream)

	val SEEDS_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: AddSeeds) = defaultInstance.mergeFrom(prototype)

}
final case class Envelope (
	`invocationId`: Key = Key.defaultInstance,
	`msg`: Msg = Msg.defaultInstance,
	`node`: Option[Node] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Envelope]
	with net.sandrogrzicic.scalabuff.Parser[Envelope] {

	def setNode(_f: Node) = copy(`node` = Some(_f))

	def clearNode = copy(`node` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `invocationId`)
		output.writeMessage(2, `msg`)
		if (`node`.isDefined) output.writeMessage(3, `node`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `invocationId`)
		__size += computeMessageSize(2, `msg`)
		if (`node`.isDefined) __size += computeMessageSize(3, `node`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Envelope = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __invocationId: Key = Key.defaultInstance
		var __msg: Msg = Msg.defaultInstance
		var __node: Option[Node] = `node`

		def __newMerged = Envelope(
			__invocationId,
			__msg,
			__node
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __invocationId = readMessage[Key](in, __invocationId, _emptyRegistry)
			case 18 => __msg = readMessage[Msg](in, __msg, _emptyRegistry)
			case 26 => __node = Some(readMessage[Node](in, __node.orElse({
				__node = Node.defaultInstance
				__node
			}).get, _emptyRegistry))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Envelope) = {
		Envelope(
			m.`invocationId`,
			m.`msg`,
			m.`node`.orElse(`node`)
		)
	}

	def getDefaultInstanceForType = Envelope.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Envelope {
	@beans.BeanProperty val defaultInstance = new Envelope()

	def parseFrom(data: Array[Byte]): Envelope = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Envelope = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Envelope = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Envelope = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Envelope] = defaultInstance.mergeDelimitedFromStream(stream)

	val INVOCATIONID_FIELD_NUMBER = 1
	val MSG_FIELD_NUMBER = 2
	val NODE_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Envelope) = defaultInstance.mergeFrom(prototype)

}
final case class OutgoingEnvelope (
	`dest`: Contact = Contact.defaultInstance,
	`envelope`: Envelope = Envelope.defaultInstance
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[OutgoingEnvelope]
	with net.sandrogrzicic.scalabuff.Parser[OutgoingEnvelope] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `dest`)
		output.writeMessage(2, `envelope`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `dest`)
		__size += computeMessageSize(2, `envelope`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): OutgoingEnvelope = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __dest: Contact = Contact.defaultInstance
		var __envelope: Envelope = Envelope.defaultInstance

		def __newMerged = OutgoingEnvelope(
			__dest,
			__envelope
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __dest = readMessage[Contact](in, __dest, _emptyRegistry)
			case 18 => __envelope = readMessage[Envelope](in, __envelope, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: OutgoingEnvelope) = {
		OutgoingEnvelope(
			m.`dest`,
			m.`envelope`
		)
	}

	def getDefaultInstanceForType = OutgoingEnvelope.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object OutgoingEnvelope {
	@beans.BeanProperty val defaultInstance = new OutgoingEnvelope()

	def parseFrom(data: Array[Byte]): OutgoingEnvelope = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): OutgoingEnvelope = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): OutgoingEnvelope = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): OutgoingEnvelope = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[OutgoingEnvelope] = defaultInstance.mergeDelimitedFromStream(stream)

	val DEST_FIELD_NUMBER = 1
	val ENVELOPE_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: OutgoingEnvelope) = defaultInstance.mergeFrom(prototype)

}
final case class ReceivedEnvelope (
	`src`: Contact = Contact.defaultInstance,
	`envelope`: Envelope = Envelope.defaultInstance
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[ReceivedEnvelope]
	with net.sandrogrzicic.scalabuff.Parser[ReceivedEnvelope] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeMessage(1, `src`)
		output.writeMessage(2, `envelope`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeMessageSize(1, `src`)
		__size += computeMessageSize(2, `envelope`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): ReceivedEnvelope = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __src: Contact = Contact.defaultInstance
		var __envelope: Envelope = Envelope.defaultInstance

		def __newMerged = ReceivedEnvelope(
			__src,
			__envelope
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __src = readMessage[Contact](in, __src, _emptyRegistry)
			case 18 => __envelope = readMessage[Envelope](in, __envelope, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: ReceivedEnvelope) = {
		ReceivedEnvelope(
			m.`src`,
			m.`envelope`
		)
	}

	def getDefaultInstanceForType = ReceivedEnvelope.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object ReceivedEnvelope {
	@beans.BeanProperty val defaultInstance = new ReceivedEnvelope()

	def parseFrom(data: Array[Byte]): ReceivedEnvelope = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): ReceivedEnvelope = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): ReceivedEnvelope = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): ReceivedEnvelope = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[ReceivedEnvelope] = defaultInstance.mergeDelimitedFromStream(stream)

	val SRC_FIELD_NUMBER = 1
	val ENVELOPE_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: ReceivedEnvelope) = defaultInstance.mergeFrom(prototype)

}
final case class InvocationTimeout (
	`contacts`: scala.collection.immutable.Seq[Contact] = Vector.empty[Contact]
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[InvocationTimeout]
	with net.sandrogrzicic.scalabuff.Parser[InvocationTimeout] {

	def setContacts(_i: Int, _v: Contact) = copy(`contacts` = `contacts`.updated(_i, _v))
	def addContacts(_f: Contact) = copy(`contacts` = `contacts` :+ _f)
	def addAllContacts(_f: Contact*) = copy(`contacts` = `contacts` ++ _f)
	def addAllContacts(_f: TraversableOnce[Contact]) = copy(`contacts` = `contacts` ++ _f)

	def clearContacts = copy(`contacts` = Vector.empty[Contact])

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		for (_v <- `contacts`) output.writeMessage(1, _v)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		for (_v <- `contacts`) __size += computeMessageSize(1, _v)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): InvocationTimeout = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		val __contacts: scala.collection.mutable.Buffer[Contact] = `contacts`.toBuffer

		def __newMerged = InvocationTimeout(
			Vector(__contacts: _*)
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __contacts += readMessage[Contact](in, Contact.defaultInstance, _emptyRegistry)
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: InvocationTimeout) = {
		InvocationTimeout(
			`contacts` ++ m.`contacts`
		)
	}

	def getDefaultInstanceForType = InvocationTimeout.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object InvocationTimeout {
	@beans.BeanProperty val defaultInstance = new InvocationTimeout()

	def parseFrom(data: Array[Byte]): InvocationTimeout = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): InvocationTimeout = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): InvocationTimeout = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): InvocationTimeout = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[InvocationTimeout] = defaultInstance.mergeDelimitedFromStream(stream)

	val CONTACTS_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: InvocationTimeout) = defaultInstance.mergeFrom(prototype)

}
final case class RegisterNetworkListener (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[RegisterNetworkListener]
	with net.sandrogrzicic.scalabuff.Parser[RegisterNetworkListener] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RegisterNetworkListener = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = RegisterNetworkListener(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: RegisterNetworkListener) = {
		RegisterNetworkListener(

		)
	}

	def getDefaultInstanceForType = RegisterNetworkListener.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object RegisterNetworkListener {
	@beans.BeanProperty val defaultInstance = new RegisterNetworkListener()

	def parseFrom(data: Array[Byte]): RegisterNetworkListener = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): RegisterNetworkListener = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): RegisterNetworkListener = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): RegisterNetworkListener = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[RegisterNetworkListener] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: RegisterNetworkListener) = defaultInstance.mergeFrom(prototype)

}
final case class NetworkListenerRegistered (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[NetworkListenerRegistered]
	with net.sandrogrzicic.scalabuff.Parser[NetworkListenerRegistered] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): NetworkListenerRegistered = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = NetworkListenerRegistered(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: NetworkListenerRegistered) = {
		NetworkListenerRegistered(

		)
	}

	def getDefaultInstanceForType = NetworkListenerRegistered.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object NetworkListenerRegistered {
	@beans.BeanProperty val defaultInstance = new NetworkListenerRegistered()

	def parseFrom(data: Array[Byte]): NetworkListenerRegistered = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): NetworkListenerRegistered = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): NetworkListenerRegistered = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): NetworkListenerRegistered = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[NetworkListenerRegistered] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: NetworkListenerRegistered) = defaultInstance.mergeFrom(prototype)

}
final case class RegisterInvocationTimeoutListener (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[RegisterInvocationTimeoutListener]
	with net.sandrogrzicic.scalabuff.Parser[RegisterInvocationTimeoutListener] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RegisterInvocationTimeoutListener = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = RegisterInvocationTimeoutListener(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: RegisterInvocationTimeoutListener) = {
		RegisterInvocationTimeoutListener(

		)
	}

	def getDefaultInstanceForType = RegisterInvocationTimeoutListener.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object RegisterInvocationTimeoutListener {
	@beans.BeanProperty val defaultInstance = new RegisterInvocationTimeoutListener()

	def parseFrom(data: Array[Byte]): RegisterInvocationTimeoutListener = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): RegisterInvocationTimeoutListener = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): RegisterInvocationTimeoutListener = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): RegisterInvocationTimeoutListener = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[RegisterInvocationTimeoutListener] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: RegisterInvocationTimeoutListener) = defaultInstance.mergeFrom(prototype)

}
final case class InvocationTimeoutListenerRegistered (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[InvocationTimeoutListenerRegistered]
	with net.sandrogrzicic.scalabuff.Parser[InvocationTimeoutListenerRegistered] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): InvocationTimeoutListenerRegistered = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = InvocationTimeoutListenerRegistered(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: InvocationTimeoutListenerRegistered) = {
		InvocationTimeoutListenerRegistered(

		)
	}

	def getDefaultInstanceForType = InvocationTimeoutListenerRegistered.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object InvocationTimeoutListenerRegistered {
	@beans.BeanProperty val defaultInstance = new InvocationTimeoutListenerRegistered()

	def parseFrom(data: Array[Byte]): InvocationTimeoutListenerRegistered = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): InvocationTimeoutListenerRegistered = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): InvocationTimeoutListenerRegistered = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): InvocationTimeoutListenerRegistered = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[InvocationTimeoutListenerRegistered] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: InvocationTimeoutListenerRegistered) = defaultInstance.mergeFrom(prototype)

}

object Protocol {
	def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
	}

	private val fromBinaryHintMap = collection.immutable.HashMap[String, Array[Byte] ⇒ com.google.protobuf.GeneratedMessageLite](
		 "Key" -> (bytes ⇒ Key.parseFrom(bytes)),
		 "Contact" -> (bytes ⇒ Contact.parseFrom(bytes)),
		 "Node" -> (bytes ⇒ Node.parseFrom(bytes)),
		 "PING" -> (bytes ⇒ PING.parseFrom(bytes)),
		 "OK" -> (bytes ⇒ OK.parseFrom(bytes)),
		 "STORE" -> (bytes ⇒ STORE.parseFrom(bytes)),
		 "FIND_NODE" -> (bytes ⇒ FIND_NODE.parseFrom(bytes)),
		 "FIND_NODE_RESP" -> (bytes ⇒ FIND_NODE_RESP.parseFrom(bytes)),
		 "FIND_VALUE" -> (bytes ⇒ FIND_VALUE.parseFrom(bytes)),
		 "FIND_VALUE_RESP" -> (bytes ⇒ FIND_VALUE_RESP.parseFrom(bytes)),
		 "Msg" -> (bytes ⇒ Msg.parseFrom(bytes)),
		 "SendMessage" -> (bytes ⇒ SendMessage.parseFrom(bytes)),
		 "AddSeeds" -> (bytes ⇒ AddSeeds.parseFrom(bytes)),
		 "Envelope" -> (bytes ⇒ Envelope.parseFrom(bytes)),
		 "OutgoingEnvelope" -> (bytes ⇒ OutgoingEnvelope.parseFrom(bytes)),
		 "ReceivedEnvelope" -> (bytes ⇒ ReceivedEnvelope.parseFrom(bytes)),
		 "InvocationTimeout" -> (bytes ⇒ InvocationTimeout.parseFrom(bytes)),
		 "RegisterNetworkListener" -> (bytes ⇒ RegisterNetworkListener.parseFrom(bytes)),
		 "NetworkListenerRegistered" -> (bytes ⇒ NetworkListenerRegistered.parseFrom(bytes)),
		 "RegisterInvocationTimeoutListener" -> (bytes ⇒ RegisterInvocationTimeoutListener.parseFrom(bytes)),
		 "InvocationTimeoutListenerRegistered" -> (bytes ⇒ InvocationTimeoutListenerRegistered.parseFrom(bytes))
	)

	def deserializePayload(payload: Array[Byte], payloadType: String): com.google.protobuf.GeneratedMessageLite = {
		fromBinaryHintMap.get(payloadType) match {
			case Some(f) ⇒ f(payload)
			case None    ⇒ throw new IllegalArgumentException(s"unimplemented deserialization of message payload of type [${payloadType}]")
		}
	}
}
